from pathlib import Path
from string import Template
import logging
import fastapi
from uvicorn import run
from pydantic import BaseModel
from langchain_community.llms import Ollama
from langchain.prompts import PromptTemplate
from langchain_core.output_parsers.string import StrOutputParser

from common import Logger, ConfigReader

# constants
API_CONFIG_SECTION = "api_config"
MODEL_CONFIG_SECTION = "model_config"
HOST_CONFIG_FIELD = "host"
PORT_CONFIG_FIELD = "port"
MODEL_CONFIG_FIELD = "model"
TRIVIA_CONFIG_PATH = Path(__file__).parent / "trivia_config.ini"
LOG_FILE_PATH = Path(__file__).parent / "logs" / "api_log.log"

# messages
MSG_PORT_IN_USE = Template("Port $port already in use")
MSG_WRONG_VALUE = "Wrong value for a parameter"
MSG_UVICORN_STARTUP_ERROR = "Error at uvicorn startup"
MSG_INTERNAL_SERVER_ERROR = "Internal problem with generating data!"
MSG_KEYBOARD_INTERRUPTION = "Keyboard interruption - exit"
MSG_INCORRECT_CATEGORY = "You have to provide a correct category!"

# setting up logging
logger = Logger(str(LOG_FILE_PATH))
# load config
config = ConfigReader(str(TRIVIA_CONFIG_PATH), logger)


class Question(BaseModel):
    """
    Data model for a question generated by the chain, to be used by API
    """
    question: str
    answer_a: str
    answer_b: str
    answer_c: str
    answer_d: str
    correct_answer: str


# AI's components
# defined once at the start of the execution
# out of its simplicity it's not contained by any function or method
llm = Ollama(model=config.get_field(MODEL_CONFIG_SECTION, MODEL_CONFIG_FIELD))
logger.log_info("LLM retrieved from Ollama")

prompt = PromptTemplate.from_template(
    "You are a trivia questions generator. For a given category: {category}, generate a question about this topic and "
    "return it in the following CSV format: "
    "'question', 'answer_a', 'answer_b', 'answer_c', 'answer_d', 'correct_answer'."
    "For example, for the topic 'countries':"
    "'What is the capital of Poland?', 'Warsaw', 'Berlin', 'Paris', 'Oslo', 'Warsaw'."
    "Only return the answer in CSV format, with values separated by commas, and nothing else. The correct answer"
    "should be the same text that an answer to be chosen has."
)
chain = prompt | llm | StrOutputParser()

app = fastapi.FastAPI(title="Trivia Generator", description="An API that generates a trivia question for a given "
                                                            "category")


@app.get("/trivia", response_model=Question)
async def generate_question(category: str):
    """
    API endpoint asynchronously returning generated question for a category given by an user

    :param category: Category of the trivia question
    :return: Either an error if there is a problem with a given category or generated data or a fully generated question
    :rtype: Question | fastapi.HTTPException
    """
    if category == "":
        logger.log_error(ValueError("Empty Category Provided"), "An empty category has been provided")
        return fastapi.HTTPException(400, MSG_INCORRECT_CATEGORY)

    data = await chain.ainvoke({"category": category})
    data = data.split(",")

    # will be replaced with normal logic
    if len(data) != 6:
        logger.log_error(ValueError("generated data does not fit the template for an answer"),
                         f"The generated data has not been up to standard: {data}")
        return fastapi.HTTPException(500, MSG_INTERNAL_SERVER_ERROR)

    logger.log_info(f"Received {data} from the chain")

    return Question(
        question=data[0],
        answer_a=data[1],
        answer_b=data[2],
        answer_c=data[3],
        answer_d=data[4],
        correct_answer=data[5]
    )

if __name__ == '__main__':
    # run the api
    # config values will be later extended
    logger.log_info(f"Starting up app at "
                    f"{(host := config.get_field(API_CONFIG_SECTION, HOST_CONFIG_FIELD))}:"
                    f"{(port := int(config.get_field(API_CONFIG_SECTION, PORT_CONFIG_FIELD)))}")
    try:
        # https coming right up
        run(
            app,
            host=host,
            port=port,
        )
    except KeyboardInterrupt:
        logger.log_exit(MSG_KEYBOARD_INTERRUPTION)
    except ValueError as e:
        logger.log_error(e)
        logger.log_exit(MSG_WRONG_VALUE, logging.ERROR)
    except SystemExit as e:
        logger.log_error(e)
        logger.log_exit(MSG_PORT_IN_USE.substitute(port=port), logging.ERROR)
    except RuntimeError as e:
        logger.log_error(e)
        logger.log_exit(MSG_UVICORN_STARTUP_ERROR, logging.ERROR)
